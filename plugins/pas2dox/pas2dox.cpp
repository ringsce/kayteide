#include "pasdoxflexlexer.h" // Includes the class declaration and FlexLexer.h
#include "globals.h"         // Includes global variable declarations
#include <iostream>
#include <fstream>
#include <cstdio> // For fprintf
#include <algorithm> // For std::transform if used in functions
#include <ctype.h> // For isalnum etc. if used in functions
#include <sstream> // For std::stringstream if used in functions

// Ensure `using namespace std;` is here if you want to avoid `std::` prefix
using namespace std;

// -- PasDoxFlexLexer Member Function Definitions --

// Destructor definition (Important for proper cleanup)
PasDoxFlexLexer::~PasDoxFlexLexer() {
    // Any cleanup specific to PasDoxFlexLexer
    // Base class destructor (~yyFlexLexer) is called automatically
}

// Constructor definition
PasDoxFlexLexer::PasDoxFlexLexer(std::istream* in, std::ostream* out)
    : yyFlexLexer(in, out) // Call yyFlexLexer constructor
{
    // Initialize global FILE* OUTPUT if needed, but consider if main should set it.
    // If your main function passes streams to the lexer, setting OUTPUT = stdout here
    // might conflict if you want output to a file.
    // If OUTPUT is strictly for debug logging, stdout/stderr is fine.
    OUTPUT = stdout;
}

// OutputLog member function definition
void PasDoxFlexLexer::OutputLog(const char* s, bool newline) {
    if (g_bDebugMode) { // g_bDebugMode is declared via globals.h
        fprintf(stderr, "%s", s);
        if (newline) fprintf(stderr, "\n");
    }
}

// OutputLog2 member function definition
void PasDoxFlexLexer::OutputLog2(const char* s1, const char* s2) {
    if (g_bDebugMode) {
        fprintf(stderr, "%s%s", s1, s2);
    }
}

// OutputLogNum member function definition
void PasDoxFlexLexer::OutputLogNum(const char* s, int num) {
    if (g_bDebugMode) {
        fprintf(stderr, "%s%d\n", s, num);
    }
}

// OutputLogHead member function definition
void PasDoxFlexLexer::OutputLogHead(const char* s) {
    if (g_bDebugMode) {
        fprintf(stderr, "*****************************************************\n");
        fprintf(stderr, "LOG: %s\n", s);
    }
}

// PushText member function definition
void PasDoxFlexLexer::PushText(const string& txt) {
    for (int i = static_cast<int>(txt.length()) - 1; i >= 0; --i) {
        yyunput(txt[i], yytext); // yyunput requires character and buffer
    }
}

// version_info member function definition (if it's a member of PasDoxFlexLexer)
void PasDoxFlexLexer::version_info() {
    fprintf(stdout, "Pas2dox version %s %s\n", version, date); // Access global 'version' and 'date'
    fprintf(stdout, "Copyright Darren Bowles 2002,2003\n\n");
    fprintf(stdout, "Pas2dox is a Pascal/Delphi/... \n");
}

// Placeholder for yylex() if you plan to define it here
// If yylex() is generated by flex, you typically don't define it here unless
// you are overriding the default generated yylex().
// For the Flex C++ API, you rely on the generated PasDoxFlexLexer::yylex().
// If you need custom behavior for the main yylex loop, you would typically:
// int PasDoxFlexLexer::yylex() {
//    // Your custom loop or call to the base class's yylex()
//    return yyFlexLexer::yylex();
// }


// Implementations of other PasDoxFlexLexer member functions here:
std::string PasDoxFlexLexer::Convert_Type(std::string s) { /* ... */ return ""; }
std::string PasDoxFlexLexer::RemoveSpaces(std::string s) { /* ... */ return ""; }
std::string PasDoxFlexLexer::Convert_Op(std::string s) { /* ... */ return ""; }
void PasDoxFlexLexer::DisplayEnum() { /* ... */ }
void PasDoxFlexLexer::RemoveParams(std::string s) { /* ... */ }
void PasDoxFlexLexer::ProcessParameterType() { /* ... */ }
void PasDoxFlexLexer::ProcessComment() { /* ... */ }
void PasDoxFlexLexer::ProcessEnd() { /* ... */ }
void PasDoxFlexLexer::OutputInheritedClass() { /* ... */ }
void PasDoxFlexLexer::ProcessEnums() { /* ... */ }
void PasDoxFlexLexer::ProcessArrays() { /* ... */ }
void PasDoxFlexLexer::ProcessFunction() { /* ... */ }
void PasDoxFlexLexer::DisplayParams() { /* ... */ }
void PasDoxFlexLexer::DisplayVariables() { /* ... */ }
std::string PasDoxFlexLexer::ChangeStrings(std::string s) { /* ... */ return ""; }

// If you need to override virtual functions from yyFlexLexer, define them here:
// int PasDoxFlexLexer::LexerInput(char* buf, int max_size) { /* ... */ return 0; }
// void PasDoxFlexLexer::LexerOutput(const char* buf, int size) { /* ... */ }
// void PasDoxFlexLexer::LexerError(const char* msg) { /* ... */ }
// int PasDoxFlexLexer::yywrap() { return 1; }
// void PasDoxFlexLexer::switch_streams(std::istream* new_in, std::ostream* new_out) { yyFlexLexer::switch_streams(new_in, new_out); }